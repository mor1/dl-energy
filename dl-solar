#!/usr/bin/env python3

# Copyright 2024 Richard Mortier <mort@cantab.net>
# SPDX-License-Identifier: BSD-3-Clause

import asyncio
import csv
import datetime
import hashlib
import json
import logging
import sys
import time

import aiohttp
import tomllib
from rich.logging import RichHandler

logging.basicConfig(
    level="INFO", format="%(message)s", datefmt="[%X]", handlers=[RichHandler()]
)
log = logging.getLogger(__name__)


def fail(s: str, n: int = -1) -> None:
    log.critical(s)
    sys.exit(n)


def sign(config: dict, ts: str) -> str:
    s = "%s%s%s" % (config["appid"], config["secret"], ts)
    signature = str(hashlib.sha512((s).encode("ascii")).hexdigest())
    log.debug(f"{config['appid']=} {ts=} {signature=}")
    return signature


def check_date(d: str):
    try:
        datetime.date.fromisoformat(d)
    except ValueError:
        fail(f"invalid date: {d=}")

    return


def fmt(r: dict | None) -> str:
    return json.dumps(r, indent=2)


async def get(config: dict, endpoint: str, params: dict) -> dict:
    timestamp = str(int(time.time()))
    signature = sign(config, timestamp)
    url = f"https://openapi.alphaess.com/api/{endpoint}"
    headers = {"appId": config["appid"], "timeStamp": timestamp, "sign": signature}

    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers, params=params) as response:
            log.debug(f"{response=}")
            data = await response.json()
            match response.status:
                case 200:
                    return data["data"]
                case _:
                    log.debug(f"{response=}")
                    fail(f"get: {response.status=} {data=}")
    assert False
    return {}  # unreached


async def main(
    config: dict,
    date: str,
) -> None:
    params = {"queryDate": date}

    async def _get(ep):
        log.debug(f"{config=} {ep=} {params=}")
        r = await get(config, ep, params)
        log.debug(f"{r=}")
        return r

    for sn in (i["sysSn"] for i in await _get("getEssList")):
        params["sysSn"] = sn

        power = await _get("getOneDayPowerBySn")  # system, day's energy consumption
        log.debug(f"{power}")
        fieldsmap = {
            "ts": "ts",
            "uploadTime": "time",
            "ppv": "from-pv(Wh)",
            "gridCharge": "from-grid(Wh)",
            "load": "house-load(Wh)",
            "feedIn": "to-grid(Wh)",
            "to-battery(Wh)": "to-battery(Wh)",
            "from-battery(Wh)": "from-battery(Wh)",
            # "pchargingPile": "to-battery(Wh)", # XXX constant 0
            "cbat": "battery-charge(%)",
        }
        power = [
            {fieldsmap[k]: v for k, v in row.items() if fieldsmap.get(k)}
            for row in power
        ]
        for row in power:
            dt = datetime.datetime.fromisoformat(row["time"]).astimezone()
            row["ts"] = int(dt.timestamp())
            row["time"] = dt.isoformat()
            generated = row["from-pv(Wh)"] + row["from-grid(Wh)"]
            load = row["to-grid(Wh)"] + row["house-load(Wh)"]
            diff = generated - load
            row["to-battery(Wh)"] = diff if diff > 0 else 0
            row["from-battery(Wh)"] = -1 * diff if diff < 0 else 0
        power = sorted(power, key=lambda row: row["ts"])

        energy = await _get("getOneDateEnergyBySn")
        log.debug(f"{energy=}")
        # XXX must run as a service; unclear update frequency
        # recent = await _get("getLastPowerData")
        # log.info(f"{recent=}")

        with open(f"{config['target']}/{date}.tsv", "w") as tsvf:
            tsvf.write(
                f"# {energy['theDate']}"
                f"\tto-battery(kWh)={energy['eCharge']}"
                f"\tfrom-battery(kWh)={energy['eDischarge']}"
                f"\tto-grid(kWh)={energy['eDischarge']}"
                f"\tfrom-grid(kWh)={energy['eInput']}"
                f"\tfrom-pv(kWh)={energy['epv']}"
                "\n"
            )
            tsvw = csv.DictWriter(
                tsvf,
                fieldnames=fieldsmap.values(),
                extrasaction="raise",
                delimiter="\t",
                dialect="excel",
            )
            tsvw.writeheader()
            for row in power:
                tsvw.writerow(row)


if __name__ == "__main__":
    with open("dl-solar.toml", "rb") as f:
        config = tomllib.load(f)

    log.debug(f"{config['appid']=}")

    DATE = sys.argv[1]  # yyyy-mm-dd
    if DATE == "yesterday":
        DATE = (datetime.date.today() - datetime.timedelta(1)).isoformat()
    check_date(DATE)

    asyncio.run(main(config, DATE))
