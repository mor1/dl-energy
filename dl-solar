#!/usr/bin/env python3

# Copyright 2024 Richard Mortier <mort@cantab.net>
# SPDX-License-Identifier: BSD-3-Clause

import asyncio
import csv
import datetime
import hashlib
import json
import logging
import pathlib
import sys
import time

import aiohttp
import click
import tomllib
from rich.logging import RichHandler

logging.basicConfig(format="%(message)s", datefmt="[%X]", handlers=[RichHandler()])
log = logging.getLogger(__name__)


def fail(s: str, n: int = -1) -> None:
    log.critical(s)
    sys.exit(n)


def check_date(d: str):
    try:
        datetime.date.fromisoformat(d)
    except ValueError:
        fail(f"invalid date: {d=}")

    return


def fmt(r: dict | None) -> str:
    return json.dumps(r, indent=2)


async def get(url: str, headers: dict, params: dict) -> dict:
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers, params=params) as response:
            log.debug(f"get: {response=}")
            data = await response.json()
            match response.status:
                case 200:
                    log.debug(f"get: {data=}")
                    return data
                case _:
                    log.debug(f"{response=}")
                    fail(f"get: {response.status=} {data=}")
    assert False
    return {}  # unreached


class Source:
    def __init__(self, config: dict, now: str) -> None:
        assert False

    async def fetch(self, date: str) -> dict:
        assert False

    def dump(self, basedir: str, date: str, data: dict) -> None:
        assert False


class AlphaESS(Source):
    def __init__(self, config, now):
        self.timestamp = now
        self.config = config

    def sign(self) -> str:
        appid = self.config["appid"]
        secret = self.config["secret"]
        timestamp = self.timestamp
        s = "%s%s%s" % (appid, secret, timestamp)
        signature = str(hashlib.sha512((s).encode("ascii")).hexdigest())
        log.debug(f"{appid=} {timestamp=} {signature=}")
        return signature

    def request(self, endpoint):
        log.debug(f"AlphaESS.request {endpoint=}")
        url = f"https://openapi.alphaess.com/api/{endpoint}"
        headers = {
            "appId": self.config["appid"],
            "timeStamp": self.timestamp,
            "sign": self.sign(),
        }
        return url, headers

    async def fetch(
        self,
        date: str,
    ):
        data = {}

        url, headers = self.request("getEssList")
        params = {"queryDate": date}
        response = await get(url, headers, params)
        log.debug(f"fetch: {response=}")
        for sn in (i["sysSn"] for i in response["data"]):
            params["sysSn"] = sn

            url, headers = self.request("getOneDayPowerBySn")
            power = await get(url, headers, params)  # system, day's energy consumption

            url, headers = self.request("getOneDateEnergyBySn")
            energy = await get(url, headers, params)

            # XXX must run as a service; unclear update frequency
            # recent = await _get("getLastPowerData")
            # log.info(f"{recent=}")

            data[sn] = {
                "power": power["data"],
                "energy": energy["data"],
            }

        log.debug(f"fetch: {fmt(data)}")
        return data

    def dump(
        self,
        basedir: str,
        date: str,
        data: dict,
    ):
        assert len(data.keys()) == 1
        data = list(data.values())[0]
        filename = f"{basedir}/alphaess/{date}.tsv"

        fieldsmap = {
            "ts": "ts",
            "uploadTime": "time",
            "ppv": "from-pv(Wh)",
            "gridCharge": "from-grid(Wh)",
            "load": "house-load(Wh)",
            "feedIn": "to-grid(Wh)",
            "to-battery(Wh)": "to-battery(Wh)",
            "from-battery(Wh)": "from-battery(Wh)",
            # "pchargingPile": "to-battery(Wh)", # XXX constant 0
            "cbat": "battery-charge(%)",
        }
        power = [
            {fieldsmap[k]: v for k, v in row.items() if fieldsmap.get(k)}
            for row in data["power"]
        ]
        for row in power:
            dt = datetime.datetime.fromisoformat(row["time"]).astimezone()
            row["ts"] = int(dt.timestamp())
            row["time"] = dt.isoformat()
            generated = row["from-pv(Wh)"] + row["from-grid(Wh)"]
            load = row["to-grid(Wh)"] + row["house-load(Wh)"]
            diff = generated - load
            row["to-battery(Wh)"] = diff if diff > 0 else 0
            row["from-battery(Wh)"] = -1 * diff if diff < 0 else 0
        power = sorted(power, key=lambda row: row["ts"])

        energy = data["energy"]
        with open(f"{filename}", "w") as tsvf:
            tsvf.write(
                f"# {energy['theDate']}"
                f"\tto-battery(kWh)={energy['eCharge']}"
                f"\tfrom-battery(kWh)={energy['eDischarge']}"
                f"\tto-grid(kWh)={energy['eDischarge']}"
                f"\tfrom-grid(kWh)={energy['eInput']}"
                f"\tfrom-pv(kWh)={energy['epv']}"
                "\n"
            )
            tsvw = csv.DictWriter(
                tsvf,
                fieldnames=fieldsmap.values(),
                extrasaction="raise",
                delimiter="\t",
                dialect="excel",
            )
            tsvw.writeheader()
            for row in power:
                tsvw.writerow(row)


class Octopus(Source):
    def __init__(self, config, now):
        self.timestamp = now
        self.config = config

    async def fetch(self, date: str) -> dict:
        return {}

    def dump(self, basedir, date, data) -> None:
        pass


class Energi(Source):
    def __init__(self, config, now):
        self.timestamp = now
        self.config = config

    async def fetch(self, date: str) -> dict:
        return {}

    def dump(self, basedir, date, data) -> None:
        pass


async def main(
    config: dict,
    sources: list,
    date: str,
) -> None:
    log.info(f"{pathlib.Path(__file__).stem} {date=}")

    for source in sources:
        data = await source.fetch(date)
        source.dump(config["basedir"], date, data)


@click.command()
@click.option("-l", "--loglevel", default="INFO", help="Set log level")
@click.option("-s", "--source", default="ALL", help="Data source from which to fetch")
@click.argument("date")  # yyyy-mm-dd
def cli(
    loglevel: str,
    source: str,
    date: str,
):
    logging.getLogger().setLevel(loglevel.upper())
    with open("dl-solar.toml", "rb") as f:
        config = tomllib.load(f)
    log.debug(f"{config=}")

    if date == "yesterday":
        date = (datetime.date.today() - datetime.timedelta(1)).isoformat()
    check_date(date)

    now = str(int(time.time()))

    sources = [
        AlphaESS(config["secrets"]["alphaess"], now),
        Octopus(config["secrets"]["octopus"], now),
        Energi(config["secrets"]["myenergi"], now),
    ]
    asyncio.run(main(config, sources, date))


if __name__ == "__main__":
    cli()
